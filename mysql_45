1. 原生的MyISAM引擎是不支持事务的，而插件InnoDB是支持的. MyISAM将数据和索引分开，而InnoDB是将聚簇索引和数据放在一个B+树的. 在查询总行数的时候，MyISAM会在磁盘上记录这个值， InnoDB会累积计数(没有where语句).
2. 读提交是指，一个事务提交之后，它做的变更才会被其他事务看到.
3. 由于不是有序的，哈希索引在做区间查询的时候很慢. 哈希表适合做等值查询.
4. 有序数组在等值查询和范围查询的场景中，性能都很优秀.
5. change buffer是buffer pool里面的一块内容，只能用于普通索引而不能用于唯一索引，因为唯一索引如果在内存中的话则不需要这块缓冲，如果不在内存，则需要从磁盘读入其他数据来判断是否是唯一索引，而不能利用这块change buffer.
6. 读提交是指提交之后, 它的变更才能被其他事务看到. 当前读是指其他事务不提交也能看到，可重复读是指事务读的数据和启动时一样.
7. 前缀索引不能用于排序.
8. MySQL为什么会抖? 一是因为redo log满了，需要清楚一些；二是因为内存满了，需要刷脏页.
9. delete表的数据是不会减小表文件的大小的，只有重建表才会压缩数据页的空洞.
10. 可重复读是InnoDB的默认隔离级别.
11. 对索引字段做函数操作，可能会破坏索引值的有序性，因此优化器放弃走树的搜索功能.
12. 每次业务代码升级时，把可能出现的，新的SQL语句explain一下，是一个很好的习惯.
13. 查询变慢的一个思路可能是锁，比如MDL锁和行锁被其他事务占了.
14. 在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立即释放，而是等到事务结束时才释放.
15. 在删除数据的时候尽量加limit, 例如: delete from t where c=10 limit 2;
16. binlog中的statment格式会产生主和备操作不一致，而row格式又会因为记录太多的内容导致占用更大的空间，占用更多的资源.
