1. main的返回值被用来指示状态.

2. 如何编译程序依赖于你使用的操作系统和编译器.

3. 如果省略了-o prog1 参数，在UNIX系统中的编译器会生成一个名为a.out的可执行文件.

4. iostream表示输入流和输出流，其中，术语“流”想要表达的是，随着时间的推移，字符是顺序生成或者消耗的.

5. 我们通常使用.h作为头文件的后缀，标准库的头文件通常不带后缀.

6. 对于不属于标准库的头文件，则用双引号包围。对于标准库的头文件，则用尖括号包围.

7. 标准错误通常写到与标准输出相同的设备上。cerr是一个ostream对象，默认情况下是不缓冲的，cerr通常用于输出错误信息或其他不属于程序正常逻辑的输出内容.

8. Python在程序运行时检查数据类型；与之相反，C++是一种静态数据类型语言，它的类型检查发生在编译时.

9. 类型char可以被解释为有符号的，也可以解释为无符号的，具体看编译器的实现，所以不建议使用char进行运算, 而应该使用signed char或者unsigned char进行实际的运算.

10. 有符号和无符号在一起混合运算时，其运算时总会先将有符号数变成无符号数后，再进行运算.

11. 对C++程序员来说, "变量"和"对象"一般可以互换使用.

12. 默认值一方面是由变量类型决定，同时定义变量的位置也会对此有影响.

13. auto 会将const丢弃，而decltype会原样输出.

14. string 和 vector 是两种最重要的标准库类型，前者支持可变长字符串，后者则表示可变长的集合。

15. 还有一种标准库类型是迭代器，它是string和vector的配套类型。常被用于访问string中的数组和vector中的元素。

16. 内置数组是一种更基础的类型， string和vector都是对它的某种抽象.

17. 头文件不应包含using声明.

18. 类既能定义通过函数名调用的操作，也能定义 <<, +等各种运算符在该类对象上的新含义.

19. C++语言中的字符串字面值并不是标准库类型string的对象， 切记，字符串字面值与string是不同的类型.

20. vector对象以及string对象的下标运算符可用于访问已存在的元素，而不能用于添加元素.

21. 所有的标准库容器都可以使用迭代器，但是其中只有少数几种才同时支持下标运算符.

22. 试图解引用一个非法迭代器或者尾后迭代器都是未被定义的行为.

23. 如果改变了某个运算对象的值, 在表达式的其他地方不要再使用这个运算对象.

24. 当不需要对容器内的对象进行写操作的时候，可以声明为const.

25. 当容器内的对象内容较大时，可以使用引用类型而避免对容器内元素的拷贝.

26. 前置版本将对象本身作为左值返回，后置版本则将对象原始值的副本作为右值返回.

27. 当不确定需要迭代多少次，使用while循环比较合适. 比如读取输入的内容.

28. 不能在范围for循环中增加容器内的元素，因为范围for循环中预存了end()的值，因此不能中途更改容器的大小.

29. break 能结束掉最近的一个switch语句.

30. 函数重载是说，一个函数名可以对应几个函数，运算符重载是说程序员可以自己重新定义运算符的含义.

31. 对象的生命周期是程序执行过程中该对象存在的时间.

32. 引用形参是它对应的实参的别名.

33. 传递可变形参: 1. 如果所有的实参类型相同，可以传递给一个名为initializer_list的标准库类型; 2. 编写一种特殊的函数，也就是所谓的可变参数模板. 3. 形参为省略符，这种功能一般只用于与C函数交互的接口程序.

34. 形参为数组的引用, 维度是类型的一部分, 例如: int (&arr)[10]; 但是, 形参为指针类型，例如, int i[10] ，此时，维度信息将不会起作用.

35. 如果函数无须改变引用形参的值，最好将其声明为常量引用.

36. main函数不能重载.

37. 尽管函数重载能在一定程度上减轻我们为函数起名字，记名字的负担，但是最好只重载那些确实非常相似的操作。有些情况下，给函数起不同的名字能使程序更易理解。一般来说，是否重载函数要看哪个更容易理解.

38. 内联inline关键字只是向编译器发出一个请求,编译器可以忽略这个请求.

39. 内联机制用于优化规模小, 流程直接，频繁调用的函数.

40. constexpr 函数不一定返回常量表达式.

41. 函数的类型由返回值类型和形参类型共同决定， 与函数名无关.

42. 一个constexpr函数被隐式地声明成内联函数.

43. 优秀的类设计者也应该密切关注那些有可能使用该类的程序员的需求。作为一个设计良好的类，既要有直观且易于使用的接口，也必须具备高效的实现过程.

44. 首先编译成员的声明，然后才轮到成员函数体(如果有的话). 注意是编译，而不是运行时分配内存.

45. 类需要控制拷贝、赋值和销毁对象时发生的行为.

46. struct 和 class 唯一的区别是，它们的默认访问权限不太一样. 类可以在它的第一个访问说明符之前定义成员。struct默认的它们的访问权限是public，而class默认的权限是private, 如果一直没有出现访问控制符，则一直为private.

47. 友元声明只能出现在类定义的内部，但是在类内出现的具体位置不限。一般来说，最好在类定义开始或者结束前的位置集中声明友元. 也就是说应该集中存放.

48. 友元不是类的成员，也不受它所在区域访问控制级别的约束.

49. 如果在构造函数中没有显示地初始化类的数据成员，也没有定义类内初始值，则会使用默认的构造函数，但是，有的时候，编译器不支持默认的构造函数.

50. 定义在类内部的成员函数是自动inline的.

51. 一个const成员函数如果以引用的形式返回*this， 那么它的返回类型将是常量引用，而常量引用无法对其对象的内容进行修改.

52. 这个额外的函数调用不会增加任何开销，因为我们在类内定义了这个函数，所以它隐式地被声明为内联函数.

53. 友元不具有传递性，每个类负责控制自己的友元类.

54. 当成员函数在类的外部定义时，也就是在类的外部写函数体，则此成员函数的返回值并不在类的作用域中，因为函数的返回值出现在函数名之前.

55. 不建议使用类的成员名字作为任何函数参数或其他局部变量使用.

56. 在很多类中，初始化和赋值的区别事关底层效率问题: 前者直接初始化数据成员，后者则先初始化再赋值. 除了效率问题外，更重要的是, 一些数据成员必须被初始化. 建议读者养成使用构造函数初始值的习惯.

57. 类中成员的初始化顺序与它们在类定义中出现顺序一致: 第一个成员先被初始化，然后第二个. 构造函数初始值列表中的顺序不具有含义.

58. 最好令构造函数初始值的顺序与成员声明的顺序保持一致. 而且如果可能的话，尽量避免使用某些成员初始化其他成员，最好是用构造函数的参数作为成员的初始值.

59. 一般来说， 我们不能在类的内部初始化静态成员. 相反的， 必须在类的外部定义和初始化每个静态成员。和其他对象一样， 一个静态成员只能定义一次.

60. 进行IO操作的函数通常以引用的方式传递和返回流. 读写一个IO对象会改变其状态，因此传递和返回的引用不能是const.

61. 当一个fstream对象被销毁时，close会被自动调用.

62. 当我们打开一个ofstream时， 文件的内容会被丢弃. 阻止一个ofstream清空给定文件内容的方法是同时制定app模式, 例如: ofstream outfile("file", ofstream::out | ofstream::app);

63. iostream 处理控制台IO, fstream 处理命名文件IO, stringstream处理内存string的IO.

64. 类 fstream 和 stringstream都是继承自类 iostream 的， 其中，输入类都继承自istreram， 输出类继承自ostream.

65. forward_list 和 array 是新 C++ 标准增加的类型。 与内置数组相比，array是一种更安全，更容易使用的数组类型. 与内置数组类似, array对象的大小是固定的. 因此， array不支持添加和删除元素以及改变容器大小的操作. forward_list 的设计目标是达到与最好的手写的单向链表数据结构相当的性能. 因此， forward_list没有size操作，因为保存或计算其大小就会比手写链表多出额外的开销. 对其他容器而言，size保证是一个快速的常量时间的操作.

66. 当不需要写访问时，应使用cbegin和cend迭代器，以防更改了容器内的内容.

67. 只有顺序容器的构造函数才接受大小参数, 关联容器并不支持.

68. 接受迭代器创建的拷贝不需要容器类型相同，而只需要元素类型相容，能转换即可.

69. assign 操作不适用于关联容器和array.

70. 赋值相关运算会导致左边容器内部的迭代器、引用和指针失效， 但是swap操作不会让它们失效.

71. 交换两个容器内容的操作保证会很快, 因为元素本身并未交换, swap只是交换了两个容器内部的数据结构.

72. 除array外， swap不对任何元素进行拷贝, 删除或者插入操作，因此可以保证在常数时间内完成. 而array的swap操作会真正交换它们的元素，因此所需时间与元素数目成正比.

73. 将元素插入到vector, deque和string中的任何位置都是合法的。 然而， 这样做可能很耗时.

74. shrink_to_fit 只是一个请求，请求capacity退回到size大小，但标准库并不保证退回内存.

75. 每个vector实现都可以选择自己的内存分配策略. 但是必须遵守的一条规则是: 只有当迫不得已时才分配新的内存.

76. 当我们使用添加和删除元素的容器操作时，必须注意这些操作可能使指向容器中元素的迭代器, 指针或引用失效.

77. 每个容器适配器都基于底层容器类型的操作定义了自己的特殊操作，我们只可以使用适配器操作， 而不能使用底层容器类型的操作.

78. 默认情况下，stack和queue是基于deque实现的，priority_queue是在vector上实现的.

79. string搜索函数返回string::size_type值，该类型是一个unsigned类型. 因此，用一个int或者带符号类型来保存这些函数的返回值不要一个好主意.

80. 虽然大多数算法遍历输入范围的方式相似，但它们使用范围中元素的方式不同. 理解算法的最基本的方法就是了解它们是否读取元素, 改变元素或者重排元素顺序.

81. 记住， 算法不会执行容器操作，因此它们自身不可能改变容器的大小.

81. 一些算法会自己向输入范围写入元素， 这些算法本质上并不危险，它们最多写入与给定序列一样多的元素.

82. 用一个单一迭代器表示第二个序列的算法都假定第二个序列都至少和第一个一样长.

83. 删除一个空的范围没有什么不良后果.

84. 目前， 我们使用过的仅有的两种可调用对象是函数和函数指针. 还有另外两种可调用对象: 重载了函数调用运算符的类， 我们将在506页介绍，以及lambda表达式.

85. lambda 不能有默认参数， 因此，实参的数量和形参的数量永远相等.

86. 如果函数返回一个lambda, 则lambda不能包含引用捕获，因为lambda里面存放的都是局部非静态变量，函数返回完成之后，这些变量都会消失.

87. 在lambda捕获列表中， 当我们混合使用隐式捕获和显式捕获时，捕获列表中的第一个元素必须是一个&或=， 此符号指定了默认捕获方式为引用或值, 而且必须是引用捕获和值捕获都存在才成立.

88. 因为IO类属于不能被拷贝的类型，因此我们只能通过引用传递它们，也就是说, 进行IO操作的函数通常以引用的方式传递和返回流。 另外， 读写一个IO对象会改变其状态，因此传递和返回的引用都不能是const.

89. 如果lambda的捕获列表为空，我们可以使用函数来代替它，但是，对于捕获局部变量的lambda，用函数来替换它就不是那么容易了. 这时候可以使用bind函数来对原函数进行改造.

90. 除了forward_list之外的标准库容器都有反向迭代器, 这是因为forward_list是单向链表, 只支持单向顺序访问.

91. 不能从一个forward_list或者一个流上创建反向迭代器.

92. 当我们从一个普通迭代器初始化一个反向迭代器，或者一个反向迭代器初始化普通迭代器，其目的迭代器和原迭代器指向的是不同的元素.

93. 接受谓词参数的算法都有附加的 _if 前缀, 写到额外目的空间的算法都在名字后面附加一个 _copy.

94. 关联容器与顺序容器有着根本的不同: 关联容器中的元素是按关键字来保存和访问的. 与之相对， 顺序容器中的元素是按它们在容器中的位置来顺序保存和访问的. 虽然关联容器的很多行为和顺序容器相同, 但其不同之处反映了关键字的作用.

95. 当只是想知道一个值是否存在时， set是最有用的.

96. size_t 是一种机器相关的无符号类型, 它被设计得足够大以便能表示内存中任意对象的大小.

97. 对于有序关联容器， map, multimap, set 以及 multiset, 关键字类型必须定义元素的比较方法. 比如是自己的定义的类类型， 必须重写 < 等方法.

98. 由于我们不能更改关键字， 所以， map中的pair类型中的key部分是const, 例如 pair<const string ,int>

99. mapped_type 是map类型所独有的类型， 例如 map<string, int>::mapped_type 是int.

100. set的迭代器也是const类型，无法更改元素.

101. 关联容器自己定义了一个名为find的成员函数， 它通过一个给定的关键字直接获取元素. 我们可以用泛型的那个find算法来查找一个元素, 但此算法会进行顺序搜索. 使用关联容器专用的find的函数会比调用泛型find快得多.

102. 使用一个不在容器中的关键字作为下标， 会添加一个具有此关键字的元素到map中.

103. 无论在有序容器还是无序容器，具有相同关键字的元素都是相邻存储.

104. 无序容器在存储上组织为一组桶， 每个桶保存0个或多个元素. 如果容器允许重复关键字, 所有具有相同关键字的元素也都会在一个桶中. 因此，无序容器的性能依赖于哈希函数的质量和桶的数量和大小.

105. 动态分配的对象的生存期与它们在哪里创建是无关的, 只有当显式地被释放时，这些对象才会销毁.

106. 动态对象的正确释放被证明是编程中极其容易出错的地方. 为了更安全地使用动态对象，标准库定义了两个智能指针类型来管理动态分配的对象. 当一个对象应该被释放时，指向它的智能指针可以确保自动地释放它.

107. 静态内存用来保存局部static对象， 类static数据成员以及定义在任何函数之外的变量. 栈内存用来保存定义在函数内的非static对象. 分配在静态或者栈内存中的对象由编译器自动创建和销毁. 对于栈对象， 仅在其定义的程序块运行时才存在; static对象在使用之前分配，在程序结束时销毁.

108. 有时， 我们会忘记释放内存， 在这种情况下就会产生内存泄露; 有时在尚有指针引用内存的情况下我们就释放了它，在这种情况下就会产生引用非法内存的指针.

109. 释放一个空指针总是没有问题的.

110. 忘记释放动态内存会导致人们常说的内存泄露问题, 因为这种内存永远不可能被归还给自由空间了. 查找内存泄露错误是非常困难的, 因为通常应用程序运行很长时间后，真正耗尽内存时，才能检测到这种错误.

111. 使用一个内置指针来访问一个智能指针所负责的对象是非常危险的，因为我们无法知道所指向的内存何时会被释放.


112. 在unique_ptr中，不能单独使用 p.release() 语句来释放指针， 因为它会返回指针，单独使用会导致内存没有被释放.

113. 智能指针类型定义了一个名为get的函数，它返回一个内置指针，指向智能指针管理的对象. 不能用这个get函数去初始化另外的一个智能指针，因为另外的智能指针可能在某个场景被释放，导致内存被释放，从而导致原来的智能指针指向了一个已经被释放的内存区域.

114. 大多数应用应该使用标准容器而不是动态分配的数组， 分配动态数组的类必须定义自己版本的操作，在拷贝，复制以及销毁对象时管理所关联的内存.
