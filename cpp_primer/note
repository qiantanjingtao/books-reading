1. main的返回值被用来指示状态.
2. 如何编译程序依赖于你使用的操作系统和编译器.
3. 如果省略了-o prog1 参数，在UNIX系统中的编译器会生成一个名为a.out的可执行文件.
4. iostream表示输入流和输出流，其中，术语“流”想要表达的是，随着时间的推移，字符是顺序生成或者消耗的.
5. 我们通常使用.h作为头文件的后缀，标准库的头文件通常不带后缀.
6. 对于不属于标准库的头文件，则用双引号包围。对于标准库的头文件，则用尖括号包围.
7. 标准错误通常写到与标准输出相同的设备上。cerr是一个ostream对象，默认情况下是不缓冲的，cerr通常用于输出错误信息或其他不属于程序正常逻辑的输出内容.
8. Python在程序运行时检查数据类型；与之相反，C++是一种静态数据类型语言，它的类型检查发生在编译时.
9. 类型char可以被解释为有符号的，也可以解释为无符号的，具体看编译器的实现，所以不建议使用char进行运算, 而应该使用signed char或者unsigned char进行实际的运算.
10. 有符号和无符号在一起混合运算时，其运算时总会先将有符号数变成无符号数后，再进行运算.
11. 对C++程序员来说, "变量"和"对象"一般可以互换使用.
12. 默认值一方面是由变量类型决定，同时定义变量的位置也会对此有影响.
13. auto 会将const丢弃，而decltype会原样输出.
14. string 和 vector 是两种最重要的标准库类型，前者支持可变长字符串，后者则表示可变长的集合。
15. 还有一种标准库类型是迭代器，它是string和vector的配套类型。常被用于访问string中的数组和vector中的元素。
16. 内置数组是一种更基础的类型， string和vector都是对它的某种抽象.
17. 头文件不应包含using声明.
18. 类既能定义通过函数名调用的操作，也能定义 <<, +等各种运算符在该类对象上的新含义.
19. C++语言中的字符串字面值并不是标准库类型string的对象， 切记，字符串字面值与string是不同的类型.
20. vector对象以及string对象的下标运算符可用于访问已存在的元素，而不能用于添加元素.
21. 所有的标准库容器都可以使用迭代器，但是其中只有少数几种才同时支持下标运算符.
22. 试图解引用一个非法迭代器或者尾后迭代器都是未被定义的行为.
23. 如果改变了某个运算对象的值, 在表达式的其他地方不要再使用这个运算对象.
24. 当不需要对容器内的对象进行写操作的时候，可以声明为const.
25. 当容器内的对象内容较大时，可以使用引用类型而避免对容器内元素的拷贝.
26. 前置版本将对象本身作为左值返回，后置版本则将对象原始值的副本作为右值返回.
27. 当不确定需要迭代多少次，使用while循环比较合适. 比如读取输入的内容.
28. 不能在范围for循环中增加容器内的元素，因为范围for循环中预存了end()的值，因此不能中途更改容器的大小.
29. break 能结束掉最近的一个switch语句.
30. 函数重载是说，一个函数名可以对应几个函数，运算符重载是说程序员可以自己重新定义运算符的含义.
31. 对象的生命周期是程序执行过程中该对象存在的时间.
32. 引用形参是它对应的实参的别名.
33. 传递可变形参: 1. 如果所有的实参类型相同，可以传递给一个名为initializer_list的标准库类型; 2. 编写一种特殊的函数，也就是所谓的可变参数模板. 3. 形参为省略符，这种功能一般只用于与C函数交互的接口程序.
34. 形参为数组的引用, 维度是类型的一部分, 例如: int (&arr)[10]; 但是, 形参为指针类型，例如, int i[10] ，此时，维度信息将不会起作用.
35. 如果函数无须改变引用形参的值，最好将其声明为常量引用.
36. main函数不能重载.
37. 尽管函数重载能在一定程度上减轻我们为函数起名字，记名字的负担，但是最好只重载那些确实非常相似的操作。有些情况下，给函数起不同的名字能使程序更易理解。一般来说，是否重载函数要看哪个更容易理解.
38. 内联inline关键字只是向编译器发出一个请求,编译器可以忽略这个请求.
39. 内联机制用于优化规模小, 流程直接，频繁调用的函数.
40. constexpr 函数不一定返回常量表达式.
41. 函数的类型由返回值类型和形参类型共同决定， 与函数名无关.
42. 一个constexpr函数被隐式地声明成内联函数.
43. 优秀的类设计者也应该密切关注那些有可能使用该类的程序员的需求。作为一个设计良好的类，既要有直观且易于使用的接口，也必须具备高效的实现过程.
44. 首先编译成员的声明，然后才轮到成员函数体(如果有的话).
45. 类需要控制拷贝、赋值和销毁对象时发生的行为.
46. struct 和 class 唯一的区别是，它们的默认访问权限不太一样. 类可以在它的第一个访问说明符之前定义成员。struct默认的它们的访问权限是public，而class默认的权限是private, 如果一直没有出现访问控制符，则一直为private.
47. 
